/**
 * Use this function to generate tags in your components,
 * @param path the path to the tags. Ideally unique accross classes in your project
 * @param keys ideintifiers for translation tags inside the path
 * @returns
 */
export const tagFactory = <K extends string, T extends string>(
  path: K,
  keys: T[]
): { path: K; keys: T[]; tags: Record<T, string> } => ({
  path,
  keys,
  tags: keys.reduce(
    (m, t) => ({ ...m, [t]: `${path}.${t}` }),
    {} as Record<T, string>
  ),
});

/**
 * Helper to extract a tag from an index, Useful to reduce boilerplate inside loops
 * Relies on how keys are declared in the factory
 * If the index is out of bounds it will return an empty string;
 *
 * @param translations a translation object generated by {@link tagFactory}
 * @param index
 * @returns
 */
export const tagAtIndex = <T extends ReturnType<typeof tagFactory>>(
  translations: T,
  index: number
) => translations.tags[translations.keys[index]] ?? '';

/**
 * Helper to extract a slice of tags.
 * Useful to reduce boilerplate or create derived objects from the main tags
 *
 * Relies on how keys are declared in the factory
 *
 * @param translations a translation object generated by {@link tagFactory}
 * @param start
 * @param end optional
 * @returns
 */
export const tagsAtRange = <T extends ReturnType<typeof tagFactory>>(
  translations: T,
  start: number,
  end?: number
) => translations.keys.slice(start, end).map((k) => translations.tags[k]);

/**
 * builds a translation path for a component,
 * (Assumes you're using the default pattern for files in this library)
 *
 * @param project the project identifier, usually the project name in camelCase `myAwesomeLib`
 * @param path the component name in camel case without the `component` suffix, i.e. `HomeComponent`-> `"home"`
 */
export const componentPath = <P extends string, K extends string>(
  project: P,
  path: K
) => `${project}.components.${path}` as const;

/**
 * builds a translation path for a service,
 * (Assumes you're using the default pattern for files in this library)
 *
 * @param project the project identifier, usually the project name in camelCase `myAwesomeLib`
 * @param path the service name in camel case without the `service` suffix, i.e. `UserService`-> "user"
 */
export const servicePath = <P extends string, K extends string>(
  project: P,
  path: K
) => `${project}.services.${path}` as const;

/**
 * builds a translation path for a directive,
 * (Assumes you're using the default pattern for files in this library)
 *
 * @param project the project identifier, usually the project name in camelCase `myAwesomeLib`
 * @param path the directive name in camel case without the `directive` suffix, i.e. `HighlightDirective`-> "highlight"
 */
export const directivePath = <P extends string, K extends string>(
  project: P,
  path: K
) => `${project}.directives.${path}` as const;

/**
 * builds a translation path for a pipe,
 * (Assumes you're using the default pattern for files in this library)
 *
 * @param project the project identifier, usually the project name in camelCase `myAwesomeLib`
 * @param path the pipe name in camel case without the `pipe` suffix, i.e. `DatePipe`-> "date"
 */
export const pipePath = <P extends string, K extends string>(
  project: P,
  path: K
) => `${project}.pipes.${path}` as const;

/**
 * builds a translation path for a resolver,
 * (Assumes you're using the default pattern for files in this library)
 *
 * @param project the project identifier, usually the project name in camelCase `myAwesomeLib`
 * @param path the resolver name in camel case without the `resolver` suffix, i.e. `UserResolver`-> "user"
 */
export const resolverPath = <P extends string, K extends string>(
  project: P,
  path: K
) => `${project}.resolvers.${path}` as const;

/**
 * builds a translation path for a guard,
 * (Assumes you're using the default pattern for files in this library)
 *
 * @param project the project identifier, usually the project name in camelCase `myAwesomeLib`
 * @param path the guard name in camel case without the `guard` suffix, i.e. `AuthGuard`-> "auth"
 */
export const guardPath = <P extends string, K extends string>(
  project: P,
  path: K
) => `${project}.guards.${path}` as const;

/**
 * builds a translation path for a store,
 * (Assumes you're using the default pattern for files in this library)
 *
 * @param project the project identifier, usually the project name in camelCase `myAwesomeLib`
 * @param path the store name in camel case without the `store` suffix, i.e. `UserStore`-> "user"
 */
export const storePath = <P extends string, K extends string>(
  project: P,
  path: K
) => `${project}.stores.${path}` as const;

/**
 * builds a translation path for a route,
 * (Assumes you're using the default pattern for files in this library)
 *
 * @param project the project identifier, usually the project name in camelCase `myAwesomeLib`
 * @param path the route name in camel case, i.e. `userProfile`-> "userProfile"
 */
export const routePath = <P extends string, K extends string>(
  project: P,
  path: K
) => `${project}.routes.${path}` as const;

/**
 * builds a custom translation path, for the cases where you do not follow
 * the standard pattern,
 *
 * @param project the project identifier, usually the project name in camelCase `myAwesomeLib`
 * @param path the route name in camel case, i.e. `userProfile`-> "userProfile"
 */
export const customPath = <
  P extends string,
  C extends string,
  K extends string
>(
  project: P,
  customPath: C,
  path: K
) => `${project}.${customPath}.${path}` as const;

/**
 * Use this function to generate a key for libraries that only expose a single component
 * which has the same name as the library. Particularly useful on complex projects where
 * components are isolated on their own libraries, most projects don't need it
 *
 * @param path
 */
export const singletonPath = <P extends string>(path: P) =>
  `${path}.components.${path}` as const;

/**
 * Factory function to generate translation path helpers for various Angular entities.
 *
 * @param project The project identifier, usually the project name in camelCase (e.g., `myAwesomeLib`).
 * @returns An object with methods to generate translation paths for components, services, directives, pipes, resolvers, guards, stores, routes, and custom/singleton cases.
 *
 * Example usage:
 * ```typescript
 *   const paths = pathFactory('myLib');
 *   paths.component('home'); // 'myLib.components.home'
 *   paths.service('user');   // 'myLib.services.user'
 * ```
 */
export const pathFactory = <P extends string>(project: P) => ({
  component: <K extends string>(componentName: K) => componentPath(project, componentName),
  service: <K extends string>(serviceName: K) => servicePath(project, serviceName),
  directive: <K extends string>(directiveName: K) => directivePath(project, directiveName),
  pipe: <K extends string>(pipeName: K) => pipePath(project, pipeName),
  resolver: <K extends string>(resolverName: K) => resolverPath(project, resolverName),
  guard: <K extends string>(guardName: K) => guardPath(project, guardName),
  store: <K extends string>(storeName: K) => storePath(project, storeName),
  route: <K extends string>(routeName: K) => routePath(project, routeName),
});
